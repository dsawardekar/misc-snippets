"
" This file was automatically generated by riml 0.2.9
" Modify with care!
"
" included: 'logger.riml'
function! g:LoggerConstructor()
  let loggerObj = {}
  let loggerObj.messages = []
  let loggerObj.log_writers = []
  let loggerObj.level = 'info'
  let loggerObj.levels = {}
  let loggerObj.levels.all = 0
  let loggerObj.levels.debug = 1
  let loggerObj.levels.info = 2
  let loggerObj.levels.warn = 3
  let loggerObj.levels.error = 4
  let loggerObj.levels.fatal = 5
  let loggerObj.levels.off = 6
  let loggerObj.colors = {}
  let loggerObj.colors.all = 0
  let loggerObj.colors.debug = 0
  let loggerObj.colors.info = 0
  let loggerObj.colors.warn = '31m'
  let loggerObj.colors.error = '31m'
  let loggerObj.colors.fatal = '31m'
  let loggerObj.colors.off = 0
  let loggerObj.add_log_writer = function('g:Logger_add_log_writer')
  let loggerObj.set_level = function('g:Logger_set_level')
  let loggerObj.get_level = function('g:Logger_get_level')
  let loggerObj.get_level_num = function('g:Logger_get_level_num')
  let loggerObj.is_loggable = function('g:Logger_is_loggable')
  let loggerObj.do_log = function('g:Logger_do_log')
  let loggerObj.args_to_message = function('g:Logger_args_to_message')
  let loggerObj.send_log = function('g:Logger_send_log')
  let loggerObj.to_color = function('g:Logger_to_color')
  let loggerObj.debug = function('g:Logger_debug')
  let loggerObj.info = function('g:Logger_info')
  let loggerObj.log = function('g:Logger_log')
  let loggerObj.warn = function('g:Logger_warn')
  let loggerObj.error = function('g:Logger_error')
  let loggerObj.fatal = function('g:Logger_fatal')
  return loggerObj
endfunction
function! g:Logger_add_log_writer(log_writer) dict
  call add(self.log_writers, a:log_writer)
endfunction
function! g:Logger_set_level(level) dict
  let self.level = a:level
endfunction
function! g:Logger_get_level() dict
  return self.level
endfunction
function! g:Logger_get_level_num(level) dict
  return self.levels[a:level]
endfunction
function! g:Logger_is_loggable(level) dict
  return self.get_level_num(a:level) >=# self.get_level_num(self.level)
endfunction
function! g:Logger_do_log(args, level) dict
  if self.is_loggable(a:level)
    let msg = self.args_to_message(a:args)
    call self.send_log(msg, a:level)
  endif
endfunction
function! g:Logger_args_to_message(args) dict
  return join(a:args, ' ')
endfunction
function! g:Logger_send_log(msg, level) dict
  let color_msg = self.to_color(a:msg, a:level)
  for log_writer in self.log_writers
    if log_writer.get_colorize()
      call log_writer.log(color_msg)
    else
      call log_writer.log(a:msg)
    endif
  endfor
endfunction
function! g:Logger_to_color(msg, level) dict
  let color = self.colors[a:level]
  if color !=# 0
    return "[" . color . a:msg . "[0m"
  else
    return a:msg
  endif
endfunction
function! g:Logger_debug(...) dict
  call self.do_log(a:000, 'debug')
endfunction
function! g:Logger_info(...) dict
  call self.do_log(a:000, 'info')
endfunction
function! g:Logger_log(...) dict
  call self.do_log(a:000, 'info')
endfunction
function! g:Logger_warn(...) dict
  call self.do_log(a:000, 'warn')
endfunction
function! g:Logger_error(...) dict
  call self.do_log(a:000, 'error')
endfunction
function! g:Logger_fatal(...) dict
  call self.do_log(a:000, 'fatal')
endfunction
function! s:get_logger()
  if !(exists('g:logger'))
    let g:logger = g:LoggerConstructor()
  endif
  return g:logger
endfunction
let s:logger = s:get_logger()
" included: 'echo_log_writer.riml'
function! g:EchoLogWriterConstructor()
  let echoLogWriterObj = {}
  let echoLogWriterObj.get_colorize = function('g:EchoLogWriter_get_colorize')
  let echoLogWriterObj.log = function('g:EchoLogWriter_log')
  return echoLogWriterObj
endfunction
function! g:EchoLogWriter_get_colorize() dict
  return 0
endfunction
function! g:EchoLogWriter_log(message) dict
  echo a:message
endfunction
" included: 'spec_timer.riml'
function! g:SpecTimerConstructor()
  let specTimerObj = {}
  let specTimerObj.start_time = 0
  let specTimerObj.end_time = 0
  let specTimerObj.start = function('g:SpecTimer_start')
  let specTimerObj.stop = function('g:SpecTimer_stop')
  let specTimerObj.get_duration = function('g:SpecTimer_get_duration')
  let specTimerObj.time_to_ms = function('g:SpecTimer_time_to_ms')
  return specTimerObj
endfunction
function! g:SpecTimer_start() dict
  let self.start_time = reltime()
endfunction
function! g:SpecTimer_stop() dict
  let self.end_time = reltime()
  let self.duration = self.time_to_ms(reltime(self.start_time))
endfunction
function! g:SpecTimer_get_duration() dict
  return self.duration
endfunction
function! g:SpecTimer_time_to_ms(time) dict
  let duration_str = reltimestr(a:time)
  let duration_split = split(duration_str, '\.')
  let seconds = str2nr(duration_split[0])
  let microseconds = str2nr(duration_split[1])
  let milliseconds = (seconds * 1000) + (microseconds / 1000)
  return milliseconds
endfunction
" included: 'spec_meta.riml'
function! g:SpecMetaConstructor(context, method)
  let specMetaObj = {}
  let specMetaObj.context = a:context
  let specMetaObj.method = a:method
  let specMetaObj.get_context = function('g:SpecMeta_get_context')
  let specMetaObj.get_method = function('g:SpecMeta_get_method')
  let specMetaObj.get_sentence = function('g:SpecMeta_get_sentence')
  let specMetaObj.set_duration = function('g:SpecMeta_set_duration')
  let specMetaObj.get_duration = function('g:SpecMeta_get_duration')
  let specMetaObj.is_slow = function('g:SpecMeta_is_slow')
  return specMetaObj
endfunction
function! g:SpecMeta_get_context() dict
  return self.context
endfunction
function! g:SpecMeta_get_method() dict
  return self.method
endfunction
function! g:SpecMeta_get_sentence() dict
  return substitute(self.get_method(), '_', ' ', 'g')
endfunction
function! g:SpecMeta_set_duration(duration) dict
  let self.duration = a:duration
endfunction
function! g:SpecMeta_get_duration() dict
  return self.duration
endfunction
function! g:SpecMeta_is_slow() dict
  return self.get_duration() ># g:speckle_slow_threshold
endfunction
" included: 'statistician.riml'
function! g:StatisticianConstructor()
  let statisticianObj = {}
  let statisticianObj.count = 0
  let statisticianObj.passes = 0
  let statisticianObj.failures = 0
  let statisticianObj.errors = 0
  let statisticianObj.pending = 0
  let statisticianObj.inc_count = function('g:Statistician_inc_count')
  let statisticianObj.inc_passes = function('g:Statistician_inc_passes')
  let statisticianObj.inc_failures = function('g:Statistician_inc_failures')
  let statisticianObj.inc_pending = function('g:Statistician_inc_pending')
  let statisticianObj.inc_errors = function('g:Statistician_inc_errors')
  let statisticianObj.inc_assertions = function('g:Statistician_inc_assertions')
  let statisticianObj.get_count = function('g:Statistician_get_count')
  let statisticianObj.get_passes = function('g:Statistician_get_passes')
  let statisticianObj.get_failures = function('g:Statistician_get_failures')
  let statisticianObj.get_pending = function('g:Statistician_get_pending')
  let statisticianObj.get_errors = function('g:Statistician_get_errors')
  let statisticianObj.get_assertions = function('g:Statistician_get_assertions')
  let statisticianObj.is_ok = function('g:Statistician_is_ok')
  let statisticianObj.is_not_ok = function('g:Statistician_is_not_ok')
  return statisticianObj
endfunction
function! g:Statistician_inc_count() dict
  let self.count += 1
endfunction
function! g:Statistician_inc_passes() dict
  call self.inc_count()
  let self.passes += 1
endfunction
function! g:Statistician_inc_failures() dict
  call self.inc_count()
  let self.failures += 1
endfunction
function! g:Statistician_inc_pending() dict
  call self.inc_count()
  let self.pending += 1
endfunction
function! g:Statistician_inc_errors() dict
  call self.inc_count()
  let self.errors += 1
endfunction
function! g:Statistician_inc_assertions() dict
  let env = g:speckle_env
  let env.assertions += 1
endfunction
function! g:Statistician_get_count() dict
  return self.count
endfunction
function! g:Statistician_get_passes() dict
  return self.passes
endfunction
function! g:Statistician_get_failures() dict
  return self.failures
endfunction
function! g:Statistician_get_pending() dict
  return self.pending
endfunction
function! g:Statistician_get_errors() dict
  return self.errors
endfunction
function! g:Statistician_get_assertions() dict
  return g:speckle_env.assertions
endfunction
function! g:Statistician_is_ok() dict
  return self.get_errors() ==# 0 && self.get_failures() ==# 0
endfunction
function! g:Statistician_is_not_ok() dict
  return !self.is_ok()
endfunction
" included: 'equality_matcher.riml'
function! g:EqualityMatcherConstructor()
  let equalityMatcherObj = {}
  let equalityMatcherObj.match = function('g:EqualityMatcher_match')
  let equalityMatcherObj.failure_message_for_match = function('g:EqualityMatcher_failure_message_for_match')
  let equalityMatcherObj.failure_message_for_mismatch = function('g:EqualityMatcher_failure_message_for_mismatch')
  return equalityMatcherObj
endfunction
function! g:EqualityMatcher_match(expected, actual) dict
  return a:actual ==# a:expected
endfunction
function! g:EqualityMatcher_failure_message_for_match(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to equal ‚Äú" . a:expected . "‚Äù"
endfunction
function! g:EqualityMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to not equal ‚Äú" . a:expected . "‚Äù"
endfunction
" included: 'boolean_matcher.riml'
function! g:BooleanMatcherConstructor()
  let booleanMatcherObj = {}
  let booleanMatcherObj.match = function('g:BooleanMatcher_match')
  let booleanMatcherObj.failure_message_for_match = function('g:BooleanMatcher_failure_message_for_match')
  let booleanMatcherObj.failure_message_for_mismatch = function('g:BooleanMatcher_failure_message_for_mismatch')
  return booleanMatcherObj
endfunction
function! g:BooleanMatcher_match(expected, actual) dict
  return a:actual ==# 1
endfunction
function! g:BooleanMatcher_failure_message_for_match(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to be true"
endfunction
function! g:BooleanMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to be false"
endfunction
" included: 'existance_matcher.riml'
function! g:ExistanceMatcherConstructor()
  let existanceMatcherObj = {}
  let existanceMatcherObj.match = function('g:ExistanceMatcher_match')
  let existanceMatcherObj.failure_message_for_match = function('g:ExistanceMatcher_failure_message_for_match')
  let existanceMatcherObj.failure_message_for_mismatch = function('g:ExistanceMatcher_failure_message_for_mismatch')
  return existanceMatcherObj
endfunction
function! g:ExistanceMatcher_match(expected, actual) dict
  return exists(a:actual)
endfunction
function! g:ExistanceMatcher_failure_message_for_match(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to exist"
endfunction
function! g:ExistanceMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to not exist"
endfunction
" included: 'above_matcher.riml'
function! g:AboveMatcherConstructor()
  let aboveMatcherObj = {}
  let aboveMatcherObj.match = function('g:AboveMatcher_match')
  let aboveMatcherObj.failure_message_for_match = function('g:AboveMatcher_failure_message_for_match')
  let aboveMatcherObj.failure_message_for_mismatch = function('g:AboveMatcher_failure_message_for_mismatch')
  return aboveMatcherObj
endfunction
function! g:AboveMatcher_match(expected, actual) dict
  return a:actual ># a:expected
endfunction
function! g:AboveMatcher_failure_message_for_match(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to be above ‚Äú" . a:expected . "‚Äù"
endfunction
function! g:AboveMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to not be above ‚Äú" . a:expected . "‚Äù"
endfunction
" included: 'below_matcher.riml'
function! g:BelowMatcherConstructor()
  let belowMatcherObj = {}
  let belowMatcherObj.match = function('g:BelowMatcher_match')
  let belowMatcherObj.failure_message_for_match = function('g:BelowMatcher_failure_message_for_match')
  let belowMatcherObj.failure_message_for_mismatch = function('g:BelowMatcher_failure_message_for_mismatch')
  return belowMatcherObj
endfunction
function! g:BelowMatcher_match(expected, actual) dict
  return a:actual <# a:expected
endfunction
function! g:BelowMatcher_failure_message_for_match(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to be below ‚Äú" . a:expected . "‚Äù"
endfunction
function! g:BelowMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to not be below ‚Äú" . a:expected . "‚Äù"
endfunction
" included: 'between_matcher.riml'
function! g:BetweenMatcherConstructor()
  let betweenMatcherObj = {}
  let betweenMatcherObj.match = function('g:BetweenMatcher_match')
  let betweenMatcherObj.failure_message_for_match = function('g:BetweenMatcher_failure_message_for_match')
  let betweenMatcherObj.failure_message_for_mismatch = function('g:BetweenMatcher_failure_message_for_mismatch')
  return betweenMatcherObj
endfunction
function! g:BetweenMatcher_match(bounds, actual) dict
  let min = a:bounds[0]
  let max = a:bounds[1]
  return a:actual >=# min && a:actual <=# max
endfunction
function! g:BetweenMatcher_failure_message_for_match(bounds, actual) dict
  let min = a:bounds[0]
  let max = a:bounds[1]
  return "expected ‚Äú" . a:actual . "‚Äù to be between ‚Äú" . min . " .. " . max . "‚Äù"
endfunction
function! g:BetweenMatcher_failure_message_for_mismatch(bounds, actual) dict
  let min = a:bounds[0]
  let max = a:bounds[1]
  return "expected ‚Äú" . a:actual . "‚Äù to not be between ‚Äú" . min . " .. " . max . "‚Äù"
endfunction
" included: 'length_matcher.riml'
function! g:LengthMatcherConstructor()
  let lengthMatcherObj = {}
  let lengthMatcherObj.match = function('g:LengthMatcher_match')
  let lengthMatcherObj.failure_message_for_match = function('g:LengthMatcher_failure_message_for_match')
  let lengthMatcherObj.failure_message_for_mismatch = function('g:LengthMatcher_failure_message_for_mismatch')
  return lengthMatcherObj
endfunction
function! g:LengthMatcher_match(expected, actual) dict
  let self.result = len(a:actual)
  return self.result ==# a:expected
endfunction
function! g:LengthMatcher_failure_message_for_match(expected, actual) dict
  return "expected length of ‚Äú" . a:actual . "‚Äù to be ‚Äú" . a:expected . "‚Äù, but was " . self.result
endfunction
function! g:LengthMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected length of ‚Äú" . a:actual . "‚Äù to not be ‚Äú" . a:expected . "‚Äù, but was " . self.result
endfunction
" included: 'atleast_matcher.riml'
function! g:AtleastMatcherConstructor()
  let atleastMatcherObj = {}
  let atleastMatcherObj.match = function('g:AtleastMatcher_match')
  let atleastMatcherObj.failure_message_for_match = function('g:AtleastMatcher_failure_message_for_match')
  let atleastMatcherObj.failure_message_for_mismatch = function('g:AtleastMatcher_failure_message_for_mismatch')
  return atleastMatcherObj
endfunction
function! g:AtleastMatcher_match(expected, actual) dict
  return a:actual >=# a:expected
endfunction
function! g:AtleastMatcher_failure_message_for_match(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to be greater than or equal to ‚Äú" . a:expected . "‚Äù"
endfunction
function! g:AtleastMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to not be greater than or equal to ‚Äú" . a:expected . "‚Äù"
endfunction
" included: 'atmost_matcher.riml'
function! g:AtmostMatcherConstructor()
  let atmostMatcherObj = {}
  let atmostMatcherObj.match = function('g:AtmostMatcher_match')
  let atmostMatcherObj.failure_message_for_match = function('g:AtmostMatcher_failure_message_for_match')
  let atmostMatcherObj.failure_message_for_mismatch = function('g:AtmostMatcher_failure_message_for_mismatch')
  return atmostMatcherObj
endfunction
function! g:AtmostMatcher_match(expected, actual) dict
  return a:actual <=# a:expected
endfunction
function! g:AtmostMatcher_failure_message_for_match(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to be less than or equal to ‚Äú" . a:expected . "‚Äù"
endfunction
function! g:AtmostMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected ‚Äú" . a:actual . "‚Äù to not be less than or equal to ‚Äú" . a:expected . "‚Äù"
endfunction
" included: 'within_matcher.riml'
function! g:WithinMatcherConstructor()
  let withinMatcherObj = {}
  let withinMatcherObj.match = function('g:WithinMatcher_match')
  let withinMatcherObj.failure_message_for_match = function('g:WithinMatcher_failure_message_for_match')
  let withinMatcherObj.failure_message_for_mismatch = function('g:WithinMatcher_failure_message_for_mismatch')
  return withinMatcherObj
endfunction
function! g:WithinMatcher_match(expected, actual) dict
  let delta = a:expected[0]
  let num = a:expected[1]
  let self.result = abs(num - a:actual)
  return self.result <=# delta
endfunction
function! g:WithinMatcher_failure_message_for_match(expected, actual) dict
  let delta = a:expected[0]
  let num = a:expected[1]
  let actual_str = printf("%f", a:actual)
  let delta_str = printf("%f", delta)
  let num_str = printf("%f", num)
  let result_str = printf('%f', self.result)
  return "expected ‚Äú" . actual_str . "‚Äù to be within +/- ‚Äú" . delta_str . "‚Äù of ‚Äú" . num_str . "‚Äù, delta was ‚Äú" . result_str . "‚Äù"
endfunction
function! g:WithinMatcher_failure_message_for_mismatch(expected, actual) dict
  let delta = a:expected[0]
  let num = a:expected[1]
  let actual_str = printf("%f", a:actual)
  let delta_str = printf("%f", delta)
  let num_str = printf("%f", num)
  let result_str = printf('%f', self.result)
  return "expected ‚Äú" . actual_str . "‚Äù to not be within +/- ‚Äú" . delta_str . "‚Äù of ‚Äú" . num_str . "‚Äù, delta was ‚Äú" . result_str . "‚Äù"
endfunction
" included: 'regexp_matcher.riml'
function! g:RegExpMatcherConstructor()
  let regExpMatcherObj = {}
  let regExpMatcherObj.match = function('g:RegExpMatcher_match')
  let regExpMatcherObj.failure_message_for_match = function('g:RegExpMatcher_failure_message_for_match')
  let regExpMatcherObj.failure_message_for_mismatch = function('g:RegExpMatcher_failure_message_for_mismatch')
  return regExpMatcherObj
endfunction
function! g:RegExpMatcher_match(pattern, expr) dict
  let result = matchstr(a:expr, a:pattern)
  return empty(result) ==# 0
endfunction
function! g:RegExpMatcher_failure_message_for_match(pattern, expr) dict
  return "expected ‚Äú" . a:pattern . "‚Äù to match " . a:expr
endfunction
function! g:RegExpMatcher_failure_message_for_mismatch(pattern, expr) dict
  return "expected ‚Äú" . a:pattern . "‚Äù to not match " . a:expr
endfunction
" included: 'dict_key_matcher.riml'
function! g:DictKeyMatcherConstructor()
  let dictKeyMatcherObj = {}
  let dictKeyMatcherObj.match = function('g:DictKeyMatcher_match')
  let dictKeyMatcherObj.failure_message_for_match = function('g:DictKeyMatcher_failure_message_for_match')
  let dictKeyMatcherObj.failure_message_for_mismatch = function('g:DictKeyMatcher_failure_message_for_mismatch')
  return dictKeyMatcherObj
endfunction
function! g:DictKeyMatcher_match(expected, actual) dict
  return has_key(a:actual, a:expected)
endfunction
function! g:DictKeyMatcher_failure_message_for_match(expected, actual) dict
  return "expected object to have key ‚Äú" . a:expected . "‚Äù"
endfunction
function! g:DictKeyMatcher_failure_message_for_mismatch(expected, actual) dict
  return "expected object to not have key ‚Äú" . a:expected . "‚Äù"
endfunction
" included: 'match_item.riml'
function! g:MatchItemConstructor(name, matcher, negate)
  let matchItemObj = {}
  let matchItemObj.name = a:name
  let matchItemObj.matcher = a:matcher
  let matchItemObj.negate = a:negate
  return matchItemObj
endfunction
" included: 'match_tester.riml'
function! g:MatchTesterConstructor()
  let matchTesterObj = {}
  let matchTesterObj.test_from_env = function('g:MatchTester_test_from_env')
  let matchTesterObj.test = function('g:MatchTester_test')
  return matchTesterObj
endfunction
function! g:MatchTester_test_from_env(matcher_name, expected) dict
  let env = g:speckle_env
  let matchers = env.matchers
  let match_item = matchers.get_match_item(a:matcher_name)
  let negate = match_item.negate
  let matcher = match_item.matcher
  let actual = env.actual
  let tester = g:MatchTesterConstructor()
  call tester.test(matcher, negate, a:expected, actual)
endfunction
function! g:MatchTester_test(matcher, negate, expected, actual) dict
  let result = a:matcher.match(a:expected, a:actual)
  let g:speckle_env.assertions += 1
  if a:negate
    if result
      let message = a:matcher.failure_message_for_mismatch(a:expected, a:actual)
      let message = "AssertionError: " . message
      throw message
    endif
  else
    if !(result)
      let message = a:matcher.failure_message_for_match(a:expected, a:actual)
      let message = "AssertionError: " . message
      throw message
    endif
  endif
endfunction
" included: 'matchers.riml'
function! g:MatchersConstructor()
  let matchersObj = {}
  let matchersObj.matchers = {}
  let matchersObj.load_defaults = function('g:Matchers_load_defaults')
  let matchersObj.get_match_items = function('g:Matchers_get_match_items')
  let matchersObj.get_match_item = function('g:Matchers_get_match_item')
  let matchersObj.define_single = function('g:Matchers_define_single')
  let matchersObj.define_pair = function('g:Matchers_define_pair')
  return matchersObj
endfunction
function! g:Matchers_load_defaults() dict
  let matcher = g:EqualityMatcherConstructor()
  call self.define_pair('to_equal', 'to_not_equal', matcher)
  call self.define_pair('to_eq', 'to_neq', matcher)
  let matcher = g:BooleanMatcherConstructor()
  call self.define_pair('to_be_true', 'to_be_false', matcher)
  call self.define_pair('to_be_ok', 'to_not_be_ok', matcher)
  let matcher = g:ExistanceMatcherConstructor()
  call self.define_pair('to_exist', 'to_not_exist', matcher)
  let matcher = g:AboveMatcherConstructor()
  call self.define_pair('to_be_above', 'to_not_be_above', matcher)
  call self.define_pair('to_be_gt', 'to_not_be_gt', matcher)
  let matcher = g:BelowMatcherConstructor()
  call self.define_pair('to_be_below', 'to_not_be_below', matcher)
  call self.define_pair('to_be_lt', 'to_not_be_lt', matcher)
  let matcher = g:BetweenMatcherConstructor()
  call self.define_pair('to_be_between', 'to_not_be_between', matcher)
  let matcher = g:LengthMatcherConstructor()
  call self.define_pair('to_have_length', 'to_not_have_length', matcher)
  let matcher = g:AtleastMatcherConstructor()
  call self.define_pair('to_be_at_least', 'to_not_be_at_least', matcher)
  call self.define_pair('to_be_gte', 'to_not_be_gte', matcher)
  let matcher = g:AtmostMatcherConstructor()
  call self.define_pair('to_be_at_most', 'to_not_be_at_most', matcher)
  call self.define_pair('to_be_lte', 'to_not_be_lte', matcher)
  let matcher = g:WithinMatcherConstructor()
  call self.define_pair('to_be_within', 'to_not_be_within', matcher)
  let matcher = g:RegExpMatcherConstructor()
  call self.define_pair('to_match', 'to_not_match', matcher)
  call self.define_pair('to_have_string', 'to_not_have_string', matcher)
  let matcher = g:DictKeyMatcherConstructor()
  call self.define_pair('to_have_key', 'to_not_have_key', matcher)
endfunction
function! g:Matchers_get_match_items() dict
  return values(self.matchers)
endfunction
function! g:Matchers_get_match_item(name) dict
  return self.matchers[a:name]
endfunction
function! g:Matchers_define_single(name, matcher) dict
  let item = g:MatchItemConstructor(a:name, a:matcher)
  let self.matchers[a:name] = item
endfunction
function! g:Matchers_define_pair(ok_name, not_ok_name, matcher) dict
  let ok_item = g:MatchItemConstructor(a:ok_name, a:matcher, 0)
  let not_ok_item = g:MatchItemConstructor(a:not_ok_name, a:matcher, 1)
  let self.matchers[a:ok_name] = ok_item
  let self.matchers[a:not_ok_name] = not_ok_item
endfunction
" included: 'file_writer.riml'
function! g:FileWriterConstructor()
  let fileWriterObj = {}
  let fileWriterObj.lines = []
  let fileWriterObj.current_line = ''
  let fileWriterObj.set_output_file = function('g:FileWriter_set_output_file')
  let fileWriterObj.write = function('g:FileWriter_write')
  let fileWriterObj.writeln = function('g:FileWriter_writeln')
  let fileWriterObj.flush_line = function('g:FileWriter_flush_line')
  let fileWriterObj.flush = function('g:FileWriter_flush')
  return fileWriterObj
endfunction
function! g:FileWriter_set_output_file(output_file) dict
  let self.output_file = a:output_file
endfunction
function! g:FileWriter_write(line) dict
  let self.current_line = self.current_line . a:line
endfunction
function! g:FileWriter_writeln(line) dict
  call add(self.lines, self.current_line . a:line)
  let self.current_line = ''
endfunction
function! g:FileWriter_flush_line() dict
  if !(self.current_line ==# '')
    call add(self.lines, self.current_line)
    let self.current_line = ''
  endif
endfunction
function! g:FileWriter_flush() dict
  call self.flush_line()
  call writefile(self.lines, self.output_file)
endfunction
" included: 'console_writer.riml'
function! g:ConsoleWriterConstructor()
  let consoleWriterObj = {}
  let consoleWriterObj.writer = g:FileWriterConstructor()
  let consoleWriterObj.set_output_file = function('g:ConsoleWriter_set_output_file')
  let consoleWriterObj.write = function('g:ConsoleWriter_write')
  let consoleWriterObj.writeln = function('g:ConsoleWriter_writeln')
  let consoleWriterObj.flush = function('g:ConsoleWriter_flush')
  let consoleWriterObj.flush_line = function('g:ConsoleWriter_flush_line')
  return consoleWriterObj
endfunction
function! g:ConsoleWriter_set_output_file(output_file) dict
  call self.writer.set_output_file(a:output_file)
endfunction
function! g:ConsoleWriter_write(line) dict
  call self.writer.write(a:line)
  echon a:line
endfunction
function! g:ConsoleWriter_writeln(line) dict
  call self.writer.writeln(a:line)
  echomsg a:line
endfunction
function! g:ConsoleWriter_flush() dict
  call self.writer.flush()
endfunction
function! g:ConsoleWriter_flush_line() dict
  call self.writer.flush_line()
endfunction
" included: 'buffer_writer.riml'
function! g:BufferWriterConstructor()
  let bufferWriterObj = {}
  let bufferWriterObj.writer = g:FileWriterConstructor()
  let bufferWriterObj.set_output_file = function('g:BufferWriter_set_output_file')
  let bufferWriterObj.strip_colors = function('g:BufferWriter_strip_colors')
  let bufferWriterObj.write = function('g:BufferWriter_write')
  let bufferWriterObj.writeln = function('g:BufferWriter_writeln')
  let bufferWriterObj.flush = function('g:BufferWriter_flush')
  let bufferWriterObj.flush_line = function('g:BufferWriter_flush_line')
  return bufferWriterObj
endfunction
function! g:BufferWriter_set_output_file(output_file) dict
  call self.writer.set_output_file(a:output_file)
endfunction
function! g:BufferWriter_strip_colors(line) dict
  return substitute(a:line, '\e\[[0-9;]\+[mK]', '', 'g')
endfunction
function! g:BufferWriter_write(line) dict
  call self.writer.write(a:line)
  let line = self.strip_colors(a:line)
  call append(line('$'), line)
  normal gJ
endfunction
function! g:BufferWriter_writeln(line) dict
  call self.writer.writeln(a:line)
  let line = self.strip_colors(a:line)
  call append(line('$'), line)
  normal G
endfunction
function! g:BufferWriter_flush() dict
  call self.writer.flush()
endfunction
function! g:BufferWriter_flush_line() dict
  call self.writer.flush_line()
endfunction
" included: 'writer_factory.riml'
function! g:WriterFactoryConstructor()
  let writerFactoryObj = {}
  let writerFactoryObj.get_writer = function('g:WriterFactory_get_writer')
  return writerFactoryObj
endfunction
function! g:WriterFactory_get_writer(writer_name) dict
  if a:writer_name ==# 'file'
    return g:FileWriterConstructor()
  elseif a:writer_name ==# 'console'
    return g:ConsoleWriterConstructor()
  elseif a:writer_name ==# 'buffer'
    return g:BufferWriterConstructor()
  else
    return g:BufferWriterConstructor()
  endif
endfunction
" included: 'file_log_writer.riml'
function! g:FileLogWriterConstructor()
  let fileLogWriterObj = {}
  let fileLogWriterObj.writer = g:FileWriterConstructor()
  let fileLogWriterObj.colorize = 1
  let fileLogWriterObj.set_log_file = function('g:FileLogWriter_set_log_file')
  let fileLogWriterObj.set_colorize = function('g:FileLogWriter_set_colorize')
  let fileLogWriterObj.get_colorize = function('g:FileLogWriter_get_colorize')
  let fileLogWriterObj.log = function('g:FileLogWriter_log')
  let fileLogWriterObj.flush = function('g:FileLogWriter_flush')
  return fileLogWriterObj
endfunction
function! g:FileLogWriter_set_log_file(log_file) dict
  call self.writer.set_output_file(a:log_file)
endfunction
function! g:FileLogWriter_set_colorize(colorize) dict
  let self.colorize = a:colorize
endfunction
function! g:FileLogWriter_get_colorize() dict
  return self.colorize
endfunction
function! g:FileLogWriter_log(message) dict
  call self.writer.writeln(a:message)
endfunction
function! g:FileLogWriter_flush() dict
  call self.writer.flush()
endfunction
" included: 'base_reporter.riml'
function! g:BaseReporterConstructor()
  let baseReporterObj = {}
  let baseReporterObj.colorize_output = 1
  let baseReporterObj.log_buffer = []
  let baseReporterObj.set_writer = function('g:BaseReporter_set_writer')
  let baseReporterObj.on_start = function('g:BaseReporter_on_start')
  let baseReporterObj.on_end = function('g:BaseReporter_on_end')
  let baseReporterObj.on_context_start = function('g:BaseReporter_on_context_start')
  let baseReporterObj.on_context_end = function('g:BaseReporter_on_context_end')
  let baseReporterObj.on_spec_start = function('g:BaseReporter_on_spec_start')
  let baseReporterObj.on_spec_end = function('g:BaseReporter_on_spec_end')
  let baseReporterObj.on_spec_pass = function('g:BaseReporter_on_spec_pass')
  let baseReporterObj.on_spec_failure = function('g:BaseReporter_on_spec_failure')
  let baseReporterObj.on_spec_error = function('g:BaseReporter_on_spec_error')
  let baseReporterObj.on_spec_pending = function('g:BaseReporter_on_spec_pending')
  let baseReporterObj.duration_to_str = function('g:BaseReporter_duration_to_str')
  let baseReporterObj.get_duration_msg = function('g:BaseReporter_get_duration_msg')
  let baseReporterObj.write_epilogue_separator = function('g:BaseReporter_write_epilogue_separator')
  let baseReporterObj.write_epilogue = function('g:BaseReporter_write_epilogue')
  let baseReporterObj.set_colorize_output = function('g:BaseReporter_set_colorize_output')
  let baseReporterObj.get_colorize_output = function('g:BaseReporter_get_colorize_output')
  let baseReporterObj.colorize = function('g:BaseReporter_colorize')
  let baseReporterObj.to_color = function('g:BaseReporter_to_color')
  let baseReporterObj.to_red = function('g:BaseReporter_to_red')
  let baseReporterObj.to_green = function('g:BaseReporter_to_green')
  let baseReporterObj.get_tick_icon = function('g:BaseReporter_get_tick_icon')
  let baseReporterObj.get_cross_icon = function('g:BaseReporter_get_cross_icon')
  let baseReporterObj.get_tick = function('g:BaseReporter_get_tick')
  let baseReporterObj.get_cross = function('g:BaseReporter_get_cross')
  let baseReporterObj.get_colorize = function('g:BaseReporter_get_colorize')
  let baseReporterObj.log = function('g:BaseReporter_log')
  let baseReporterObj.has_logs = function('g:BaseReporter_has_logs')
  let baseReporterObj.flush_log_buffer = function('g:BaseReporter_flush_log_buffer')
  let baseReporterObj.write_log_line = function('g:BaseReporter_write_log_line')
  return baseReporterObj
endfunction
function! g:BaseReporter_set_writer(writer) dict
  let self.writer = a:writer
endfunction
function! g:BaseReporter_on_start(stats) dict
endfunction
function! g:BaseReporter_on_end(duration, stats) dict
  call self.write_epilogue(a:duration, a:stats)
endfunction
function! g:BaseReporter_on_context_start(context, stats) dict
endfunction
function! g:BaseReporter_on_context_end(context, stats) dict
endfunction
function! g:BaseReporter_on_spec_start(meta, stats) dict
endfunction
function! g:BaseReporter_on_spec_end(meta, stats) dict
endfunction
function! g:BaseReporter_on_spec_pass(meta, stats) dict
endfunction
function! g:BaseReporter_on_spec_failure(meta, err, stats) dict
endfunction
function! g:BaseReporter_on_spec_error(meta, err, stats) dict
endfunction
function! g:BaseReporter_on_spec_pending(meta, stats) dict
endfunction
function! g:BaseReporter_duration_to_str(duration) dict
  let time = a:duration
  if time >=# 1000
    let time = time / 1000
    return time . "s"
  else
    return time . "ms"
  endif
endfunction
function! g:BaseReporter_get_duration_msg(meta) dict
  if a:meta.is_slow()
    let duration_str = self.duration_to_str(a:meta.get_duration())
    return "(" . duration_str . ")"
  else
    return ''
  endif
endfunction
function! g:BaseReporter_write_epilogue_separator() dict
  call self.writer.writeln("----------------------------------------------------")
endfunction
function! g:BaseReporter_write_epilogue(duration, stats) dict
  call self.write_epilogue_separator()
  let duration_str = self.duration_to_str(a:duration)
  if a:stats.is_ok()
    let icon = self.get_tick_icon()
  else
    let icon = self.get_cross_icon()
  endif
  call self.writer.writeln(self.to_color(icon . " " . a:stats.get_count() . " tests completed (" . duration_str . ")", a:stats))
  call self.writer.writeln("Passed: " . a:stats.get_passes() . ", Failures: " . a:stats.get_failures() . ", Errors: " . a:stats.get_errors() . ", Assertions: " . a:stats.get_assertions())
endfunction
function! g:BaseReporter_set_colorize_output(colorize_output) dict
  let self.colorize_output = a:colorize_output
endfunction
function! g:BaseReporter_get_colorize_output() dict
  return self.colorize_output
endfunction
function! g:BaseReporter_colorize(str, color) dict
  if self.get_colorize_output()
    return "[" . a:color . a:str . "[0m"
  else
    return a:str
  endif
endfunction
function! g:BaseReporter_to_color(str, stats) dict
  if a:stats.is_ok()
    return self.to_green(a:str)
  else
    return self.to_red(a:str)
  endif
endfunction
function! g:BaseReporter_to_red(str) dict
  return self.colorize(a:str, '31m')
endfunction
function! g:BaseReporter_to_green(str) dict
  return self.colorize(a:str, '32m')
endfunction
function! g:BaseReporter_get_tick_icon() dict
  return '‚úì'
endfunction
function! g:BaseReporter_get_cross_icon() dict
  return '‚úñ'
endfunction
function! g:BaseReporter_get_tick() dict
  return self.to_green(self.get_tick_icon())
endfunction
function! g:BaseReporter_get_cross() dict
  return self.to_red(self.get_cross_icon())
endfunction
function! g:BaseReporter_get_colorize() dict
  return self.get_colorize_output()
endfunction
function! g:BaseReporter_log(message) dict
  call add(self.log_buffer, a:message)
endfunction
function! g:BaseReporter_has_logs() dict
  return len(self.log_buffer) ># 0
endfunction
function! g:BaseReporter_flush_log_buffer() dict
  if self.has_logs()
    call self.writer.writeln('')
    for line in self.log_buffer
      call self.write_log_line(line)
    endfor
    call self.writer.writeln('')
    let self.log_buffer = []
  endif
endfunction
function! g:BaseReporter_write_log_line(line) dict
  call self.writer.writeln("log: " . a:line)
endfunction
" included: 'spec_reporter.riml'
function! g:SpecReporterConstructor()
  let specReporterObj = {}
  let baseReporterObj = g:BaseReporterConstructor()
  call extend(specReporterObj, baseReporterObj)
  let specReporterObj.indents = 0
  let specReporterObj.log_buffer = []
  let specReporterObj.write = function('g:SpecReporter_write')
  let specReporterObj.on_start = function('g:SpecReporter_on_start')
  let specReporterObj.on_context_start = function('g:SpecReporter_on_context_start')
  let specReporterObj.on_context_end = function('g:SpecReporter_on_context_end')
  let specReporterObj.on_spec_pass = function('g:SpecReporter_on_spec_pass')
  let specReporterObj.on_spec_failure = function('g:SpecReporter_on_spec_failure')
  let specReporterObj.on_spec_error = function('g:SpecReporter_on_spec_error')
  let specReporterObj.indent_to_str = function('g:SpecReporter_indent_to_str')
  let specReporterObj.indent = function('g:SpecReporter_indent')
  let specReporterObj.unindent = function('g:SpecReporter_unindent')
  let specReporterObj.write_epilogue_separator = function('g:SpecReporter_write_epilogue_separator')
  let specReporterObj.write_log_line = function('g:SpecReporter_write_log_line')
  let specReporterObj.BaseReporter_write_epilogue_separator = function('g:BaseReporter_write_epilogue_separator')
  return specReporterObj
endfunction
function! g:SpecReporter_write(msg) dict
  let line = self.indent_to_str() . a:msg
  call self.writer.writeln(line)
endfunction
function! g:SpecReporter_on_start(stats) dict
endfunction
function! g:SpecReporter_on_context_start(context, stats) dict
  call self.write(a:context)
  call self.indent(1)
endfunction
function! g:SpecReporter_on_context_end(context, stats) dict
  call self.unindent(1)
endfunction
function! g:SpecReporter_on_spec_pass(meta, stats) dict
  let duration_msg = self.get_duration_msg(a:meta)
  call self.write(self.get_tick() . " " . a:meta.get_sentence() . " " . duration_msg)
  call self.indent(2)
  call self.flush_log_buffer()
  call self.unindent(2)
endfunction
function! g:SpecReporter_on_spec_failure(meta, err, stats) dict
  call self.write(self.get_cross() . " " . self.to_red(a:meta.get_sentence()))
  call self.indent(2)
  call self.write(self.to_red(a:err))
  call self.flush_log_buffer()
  call self.unindent(2)
endfunction
function! g:SpecReporter_on_spec_error(meta, err, stats) dict
  call self.on_spec_failure(a:meta, a:err, a:stats)
endfunction
function! g:SpecReporter_indent_to_str() dict
  return repeat("  ", self.indents)
endfunction
function! g:SpecReporter_indent(size) dict
  let self.indents += a:size
endfunction
function! g:SpecReporter_unindent(size) dict
  let self.indents -= a:size
endfunction
function! g:SpecReporter_write_epilogue_separator() dict
  call self.writer.writeln('')
  call self.BaseReporter_write_epilogue_separator()
endfunction
function! g:SpecReporter_write_log_line(line) dict
  call self.write("log: " . a:line)
endfunction
" included: 'min_reporter.riml'
function! g:MinReporterConstructor()
  let minReporterObj = {}
  let baseReporterObj = g:BaseReporterConstructor()
  call extend(minReporterObj, baseReporterObj)
  let minReporterObj.on_spec_failure = function('g:MinReporter_on_spec_failure')
  let minReporterObj.on_spec_error = function('g:MinReporter_on_spec_error')
  let minReporterObj.write_epilogue_separator = function('g:MinReporter_write_epilogue_separator')
  let minReporterObj.BaseReporter_write_epilogue_separator = function('g:BaseReporter_write_epilogue_separator')
  return minReporterObj
endfunction
function! g:MinReporter_on_spec_failure(meta, err, stats) dict
  let name = a:meta.get_sentence()
  let context = a:meta.get_context()
  call self.writer.writeln(self.to_red(context . " #" . name . " - " . a:err))
endfunction
function! g:MinReporter_on_spec_error(meta, err, stats) dict
  call self.on_spec_failure(a:meta, a:err, a:stats)
endfunction
function! g:MinReporter_write_epilogue_separator() dict
  call self.flush_log_buffer()
  call self.BaseReporter_write_epilogue_separator()
endfunction
" included: 'tap_reporter.riml'
function! g:TAPReporterConstructor()
  let tAPReporterObj = {}
  let baseReporterObj = g:BaseReporterConstructor()
  call extend(tAPReporterObj, baseReporterObj)
  let tAPReporterObj.on_start = function('g:TAPReporter_on_start')
  let tAPReporterObj.on_spec_start = function('g:TAPReporter_on_spec_start')
  let tAPReporterObj.on_spec_end = function('g:TAPReporter_on_spec_end')
  let tAPReporterObj.on_spec_pass = function('g:TAPReporter_on_spec_pass')
  let tAPReporterObj.on_spec_failure = function('g:TAPReporter_on_spec_failure')
  let tAPReporterObj.on_spec_error = function('g:TAPReporter_on_spec_error')
  let tAPReporterObj.on_spec_pending = function('g:TAPReporter_on_spec_pending')
  let tAPReporterObj.get_preamble = function('g:TAPReporter_get_preamble')
  return tAPReporterObj
endfunction
function! g:TAPReporter_on_start(stats) dict
endfunction
function! g:TAPReporter_on_spec_start(meta, stats) dict
endfunction
function! g:TAPReporter_on_spec_end(meta, stats) dict
endfunction
function! g:TAPReporter_on_spec_pass(meta, stats) dict
  let name = a:meta.get_sentence()
  let duration_msg = self.get_duration_msg(a:meta)
  let preamble = self.get_preamble('ok', a:stats.get_count(), a:meta.get_context())
  call self.writer.writeln(preamble . " #" . name . " " . duration_msg)
  call self.flush_log_buffer()
endfunction
function! g:TAPReporter_on_spec_failure(meta, err, stats) dict
  let name = a:meta.get_sentence()
  let preamble = self.get_preamble('not ok', a:stats.get_count(), a:meta.get_context())
  call self.writer.writeln(preamble . " #" . name . " - " . a:err)
  call self.flush_log_buffer()
endfunction
function! g:TAPReporter_on_spec_error(meta, err, stats) dict
  let name = a:meta.get_sentence()
  let preamble = self.get_preamble('not ok', a:stats.get_count(), a:meta.get_context())
  call self.writer.writeln(preamble . " #" . name . " - " . a:err)
  call self.flush_log_buffer()
endfunction
function! g:TAPReporter_on_spec_pending(meta, stats) dict
endfunction
function! g:TAPReporter_get_preamble(status, count, context) dict
  let msg = a:status . " " . a:count . " - " . a:context
  return msg
endfunction
" included: 'dotmatrix_reporter.riml'
function! g:DotMatrixReporterConstructor()
  let dotMatrixReporterObj = {}
  let baseReporterObj = g:BaseReporterConstructor()
  call extend(dotMatrixReporterObj, baseReporterObj)
  let dotMatrixReporterObj.dots = 0
  let dotMatrixReporterObj.line_buffer = []
  let dotMatrixReporterObj.log_messages = []
  let dotMatrixReporterObj.write = function('g:DotMatrixReporter_write')
  let dotMatrixReporterObj.on_spec_pass = function('g:DotMatrixReporter_on_spec_pass')
  let dotMatrixReporterObj.on_spec_failure = function('g:DotMatrixReporter_on_spec_failure')
  let dotMatrixReporterObj.on_spec_error = function('g:DotMatrixReporter_on_spec_error')
  let dotMatrixReporterObj.write_epilogue_separator = function('g:DotMatrixReporter_write_epilogue_separator')
  return dotMatrixReporterObj
endfunction
function! g:DotMatrixReporter_write(msg) dict
  if self.dots ># 50
    call self.writer.writeln(a:msg)
    let self.dots = 0
  else
    call self.writer.write(a:msg)
  endif
endfunction
function! g:DotMatrixReporter_on_spec_pass(meta, stats) dict
  let self.dots += 1
  call self.write('.')
endfunction
function! g:DotMatrixReporter_on_spec_failure(meta, err, stats) dict
  let self.dots += 1
  call self.write(self.to_red("x"))
  let name = a:meta.get_sentence()
  let context = a:meta.get_context()
  call add(self.line_buffer, self.to_red(context . " #" . name))
  call add(self.line_buffer, self.to_red("    " . a:err))
  call add(self.line_buffer, '')
endfunction
function! g:DotMatrixReporter_on_spec_error(meta, err, stats) dict
  call self.on_spec_failure(a:meta, a:err, a:stats)
endfunction
function! g:DotMatrixReporter_write_epilogue_separator() dict
  call self.flush_log_buffer()
  call self.writer.writeln('')
  for line in self.line_buffer
    call self.writer.writeln(line)
  endfor
  call self.writer.writeln("")
endfunction
" included: 'reporter_factory.riml'
function! g:ReporterFactoryConstructor()
  let reporterFactoryObj = {}
  let reporterFactoryObj.get_reporter = function('g:ReporterFactory_get_reporter')
  return reporterFactoryObj
endfunction
function! g:ReporterFactory_get_reporter(reporter_name) dict
  if a:reporter_name ==# 'spec'
    return g:SpecReporterConstructor()
  elseif a:reporter_name ==# 'min'
    return g:MinReporterConstructor()
  elseif a:reporter_name ==# 'tap'
    return g:TAPReporterConstructor()
  elseif a:reporter_name ==# 'dot'
    return g:DotMatrixReporterConstructor()
  else
    return g:SpecReporterConstructor()
  endif
endfunction
" included: 'spec_runner.riml'
function! g:SpecRunnerConstructor(spec)
  let specRunnerObj = {}
  let specRunnerObj.spec = a:spec
  let specRunnerObj.stopped = 0
  let specRunnerObj.bail = 0
  let specRunnerObj.bailed = 0
  let specRunnerObj.tag = ''
  let specRunnerObj.set_bail = function('g:SpecRunner_set_bail')
  let specRunnerObj.set_tag = function('g:SpecRunner_set_tag')
  let specRunnerObj.has_bailed = function('g:SpecRunner_has_bailed')
  let specRunnerObj.start = function('g:SpecRunner_start')
  let specRunnerObj.call_hook = function('g:SpecRunner_call_hook')
  let specRunnerObj.stop = function('g:SpecRunner_stop')
  let specRunnerObj.is_test_method = function('g:SpecRunner_is_test_method')
  let specRunnerObj.is_method_tagged = function('g:SpecRunner_is_method_tagged')
  let specRunnerObj.can_run_test_for = function('g:SpecRunner_can_run_test_for')
  return specRunnerObj
endfunction
function! g:SpecRunner_set_bail(bail) dict
  let self.bail = a:bail
endfunction
function! g:SpecRunner_set_tag(tag) dict
  let self.tag = a:tag
endfunction
function! g:SpecRunner_has_bailed() dict
  return self.bailed
endfunction
function! g:SpecRunner_start(reporter, stats) dict
  let spec = self.spec
  let did_fail = 0
  let context = self.call_hook('describe')
  call a:reporter.on_context_start(context, a:stats)
  call self.call_hook('before')
  for method in keys(spec)
    if self.stopped
      break
    endif
    if self.can_run_test_for(method)
      let timer = g:SpecTimerConstructor()
      let meta = g:SpecMetaConstructor(context, method)
      call a:reporter.on_spec_start(meta, a:stats)
      let result = 0
      try
        call self.call_hook('before_each')
        call timer.start()
        call eval("spec." . method . "()")
        call timer.stop()
        call self.call_hook('after_each')
        call meta.set_duration(timer.get_duration())
        call a:stats.inc_passes()
        call a:reporter.on_spec_pass(meta, a:stats)
      catch /Unknown function.*expect/
        let did_fail = 1
        call a:stats.inc_failures()
        let exception = 'DSLError: expect() not found, dsl.riml may not be included'
        call a:reporter.on_spec_failure(meta, exception, a:stats)
      catch /Unknown function.*define_matcher/
        let did_fail = 1
        call a:stats.inc_failures()
        let exception = 'DSLError: define_matcher() not found, dsl.riml may not be included'
        call a:reporter.on_spec_failure(meta, exception, a:stats)
      catch /^AssertionError/
        let did_fail = 1
        call a:stats.inc_failures()
        call a:reporter.on_spec_failure(meta, v:exception, a:stats)
      catch /.*/
        let did_fail = 1
        call a:stats.inc_errors()
        call a:reporter.on_spec_error(meta, v:exception, a:stats)
      endtry
      call a:reporter.on_spec_end(meta, a:stats)
      redraw
      if did_fail && self.bail
        let self.bailed = 1
        break
      endif
    endif
  endfor
  call self.call_hook('after')
  call a:reporter.on_context_end(context, a:stats)
endfunction
function! g:SpecRunner_call_hook(hook) dict
  let spec = self.spec
  if has_key(spec, a:hook)
    return eval("spec." . a:hook . "()")
  else
    return "Undefined hook: " . a:hook
  endif
endfunction
function! g:SpecRunner_stop() dict
  let self.stopped = 1
endfunction
function! g:SpecRunner_is_test_method(method) dict
  return a:method =~# '^it'
endfunction
function! g:SpecRunner_is_method_tagged(method) dict
  return a:method =~# "_" . self.tag . "$"
endfunction
function! g:SpecRunner_can_run_test_for(method) dict
  if self.tag ==# ''
    return self.is_test_method(a:method)
  else
    return self.is_test_method(a:method) && self.is_method_tagged(a:method)
  endif
endfunction
" included: 'runner.riml'
function! g:RunnerConstructor()
  let runnerObj = {}
  let runnerObj.specs = []
  let runnerObj.halt = 0
  let runnerObj.stopped = 0
  let runnerObj.bail = 0
  let runnerObj.tag = ''
  let runnerObj.set_bail = function('g:Runner_set_bail')
  let runnerObj.get_bail = function('g:Runner_get_bail')
  let runnerObj.set_tag = function('g:Runner_set_tag')
  let runnerObj.get_tag = function('g:Runner_get_tag')
  let runnerObj.add = function('g:Runner_add')
  let runnerObj.start = function('g:Runner_start')
  let runnerObj.stop = function('g:Runner_stop')
  return runnerObj
endfunction
function! g:Runner_set_bail(bail) dict
  let self.bail = a:bail
endfunction
function! g:Runner_get_bail() dict
  return self.bail
endfunction
function! g:Runner_set_tag(tag) dict
  let self.tag = a:tag
endfunction
function! g:Runner_get_tag() dict
  return self.tag
endfunction
function! g:Runner_add(spec) dict
  call add(self.specs, a:spec)
endfunction
function! g:Runner_start(reporter, stats) dict
  call a:reporter.on_start(a:stats)
  let timer = g:SpecTimerConstructor()
  call timer.start()
  for spec in self.specs
    if self.stopped
      break
    endif
    let spec_runner = g:SpecRunnerConstructor(spec)
    call spec_runner.set_bail(self.get_bail())
    call spec_runner.set_tag(self.get_tag())
    call spec_runner.start(a:reporter, a:stats)
    if spec_runner.has_bailed()
      let self.stopped = 1
    endif
  endfor
  call timer.stop()
  call a:reporter.on_end(timer.get_duration(), a:stats)
endfunction
function! g:Runner_stop() dict
  let self.stopped = 1
endfunction
" included: 'expectation.riml'
function! g:ExpectationConstructor(actual)
  let expectationObj = {}
  let expectationObj.actual = a:actual
  let expectationObj.load = function('g:Expectation_load')
  return expectationObj
endfunction
function! g:Expectation_load(matchers) dict
  call a:matchers.load_defaults()
  let match_tester = g:MatchTesterConstructor()
  let match_items = a:matchers.get_match_items()
  for match_item in match_items
    let func_name = "g:Expectation_" . match_item.name
    let matcher_func = "function! " . func_name . "(...) dict  \n  if a:0 == 0\n    let expected = 'null'\n  else\n    let expected = a:1\n  endif\n\n  let matcher_name = '" . match_item.name . "'\n  let match_tester = g:MatchTesterConstructor()\n  call match_tester.test_from_env(matcher_name, expected)\"\nendfunction\"   "
    exe matcher_func
    let self[match_item.name] = function(func_name)
  endfor
endfunction
function! g:SpeckleConstructor()
  let speckleObj = {}
  let speckleObj.configure = function('g:Speckle_configure')
  let speckleObj.options = function('g:Speckle_options')
  let speckleObj.option = function('g:Speckle_option')
  let speckleObj.get_writer = function('g:Speckle_get_writer')
  let speckleObj.get_reporter = function('g:Speckle_get_reporter')
  let speckleObj.is_file_mode = function('g:Speckle_is_file_mode')
  let speckleObj.get_output_file = function('g:Speckle_get_output_file')
  let speckleObj.get_reporter_name = function('g:Speckle_get_reporter_name')
  let speckleObj.get_slow_threshold = function('g:Speckle_get_slow_threshold')
  let speckleObj.get_colorize = function('g:Speckle_get_colorize')
  let speckleObj.get_bail = function('g:Speckle_get_bail')
  let speckleObj.get_tag = function('g:Speckle_get_tag')
  let speckleObj.run = function('g:Speckle_run')
  let speckleObj.add_specs = function('g:Speckle_add_specs')
  return speckleObj
endfunction
function! g:Speckle_configure() dict
  let options_map = {'output_file': '"speckle.log"', 'file_mode': '0', 'reporter_name': '"spec"', 'slow_threshold': '10', 'colorize': '1', 'bail': '0', 'tag': '""'}
  call self.options(options_map)
endfunction
function! g:Speckle_options(options_map) dict
  for [name, value] in items(a:options_map)
    call self.option(name, value)
  endfor
endfunction
function! g:Speckle_option(variable, default) dict
  if !exists("g:speckle_" . a:variable)
    execute "let g:speckle_" . a:variable . " = " . a:default
  endif
endfunction
function! g:Speckle_get_writer() dict
  let factory = g:WriterFactoryConstructor()
  let writer = factory.get_writer('buffer')
  if self.is_file_mode()
    call writer.set_output_file(self.get_output_file())
  endif
  return writer
endfunction
function! g:Speckle_get_reporter(writer) dict
  let factory = g:ReporterFactoryConstructor()
  let reporter = factory.get_reporter(self.get_reporter_name())
  call reporter.set_writer(a:writer)
  let logger = s:get_logger()
  call logger.add_log_writer(reporter)
  return reporter
endfunction
function! g:Speckle_is_file_mode() dict
  return g:speckle_file_mode
endfunction
function! g:Speckle_get_output_file() dict
  return g:speckle_output_file
endfunction
function! g:Speckle_get_reporter_name() dict
  return g:speckle_reporter_name
endfunction
function! g:Speckle_get_slow_threshold() dict
  return g:speckle_slow_threshold
endfunction
function! g:Speckle_get_colorize() dict
  return g:speckle_colorize
endfunction
function! g:Speckle_get_bail() dict
  return g:speckle_bail
endfunction
function! g:Speckle_get_tag() dict
  return g:speckle_tag
endfunction
function! g:Speckle_run() dict
  call self.configure()
  let writer = self.get_writer()
  let stats = g:StatisticianConstructor()
  let reporter = self.get_reporter(writer)
  call reporter.set_colorize_output(self.get_colorize())
  let runner = g:RunnerConstructor()
  call runner.set_bail(self.get_bail())
  call runner.set_tag(self.get_tag())
  let functions = ''
  redir => functions
  silent function /SpecConstructor$/
  redir END
  call self.add_specs(runner, functions)
  call runner.start(reporter, stats)
  if self.is_file_mode()
    call writer.flush()
  endif
endfunction
function! g:Speckle_add_specs(runner, lines) dict
  let classes = split(a:lines, "\n")
  call map(classes, "substitute(v:val, 'function ', '', '')")
  for klass in classes
    call eval("a:runner.add(" . klass . ")")
  endfor
endfunction
